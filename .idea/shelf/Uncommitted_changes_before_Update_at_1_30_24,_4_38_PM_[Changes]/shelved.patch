Index: keithley_pstat.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>'''Communication to the Keithley 2450 source-measure unit.\nwritten by rst on 27/10/20\nilia.kulikov@fu-berlin.de'''\n\nimport numpy as np\nimport pyvisa as visa\nfrom time import sleep\nfrom math import sin\nfrom datetime import datetime  # this thing gets current time\nfrom multiprocessing import Queue\n\nimport random # for fake data\nimport cv # a CV object, for saving and running a cv\nimport chg # a CHG object, for saving and running a chg\n\n#CURRENTSENSITIVITYLIMIT = 5e-3 # change it for different samples\n\nclass pstat (object):\n    type = 'potentiostat'\n    model = '2450'                    # default model is 2450 that is the pstat at Lyra\n\n    address = []\n    address.append('USB0::0x05E6::0x2450::04509830::INSTR') # new pstat\n    address.append('USB0::0x05E6::0x2450::04431893::INSTR') # old pstat\n    address.append('USB0::1510::9296::04509830::0::INSTR')  # old pstat at e1\n    address.append('USB0::1510::9296::04431893::0::INSTR') # old pstat\n    address.append('GPIB0::18::INSTR')  # any pstat at lyra. Mind the GPIB settings of the thing!\n\n\n    device = visa.Resource            # pyvisa device that is populated with the constructor\n    rm = visa.ResourceManager         # visa resource manager, the communicator makes it\n    fake = False                      # use simulated outputs. Used for testing outside the lab.\n\n    q = None # potentiostat sends data to a queue.\n\n    GlobalInterruptFlag = False       # emergency break handle\n\n    def __init__(self, rm: visa.ResourceManager, model: str): # when create a lia you'd better have a resource manager already working\n        '''create an instance of the pstat object''' # создать объект потенциостата.\n        self.rm = rm\n        self.connect(model)\n        self.write('*RST')  # ресетнем ка мы его на всякий случай\n        self.write('*IDN?') # и спросим, как его зовут\n        response = self.read()\n        self.play_tune()\n        self.write('DISP:SCR SWIPE_GRAP')\n        self.write('SENS:CURR:RSEN ON') # 4 WIRE SENSING MODE.\n        self.write('SENS:FUNC \\'CURR\\'')\n        self.write('SENS:CURR:RANG:AUTO OFF')\n        #self.write('SENS:CURR:RANG %.4f' % (1e-3))\n        self.write('SENS:CURR:UNIT AMP') # double check it\n        self.write('SENS:CURR:OCOM ON')\n        self.write('SOUR:FUNC VOLT')\n        self.write('SOUR:VOLT 0')\n        self.write('SOUR:VOLT:ILIM %.4f'%(100e-6))\n        \n        self.write('COUNT 1') # 1 points of current to measuer\n\n################## CHANGE THIS FOR DITS!!! ######################\n        self.ConfigureForTransient() # ! change for PDITS. for testing ok.\n#################################################################\n\n        self.print(response)\n\n    def connect(self, model):\n        try:\n            self.device.close()\n        except:\n            print('no potentiostat open. connecting.')\n        print('connecting to Keithley',model)\n        for addr in self.address:\n            print(self.fake)\n            try:\n                self.device = self.rm.open_resource(addr)\n                print('got a VISA instrument for Potentiostat: %s'%self.device)\n                self.address = addr\n                return self.device\n            except:\n                    print('failed to get Pstat at ', addr)\n\n\n        self.fake = True\n        self.device = 0\n                    #self.address = 'N/C'\n        if self.fake:\n            self.print('Using fake Pstat')\n\n    def write(self, command):\n        '''write data to the Pstat, many lines can be accepted as an argument. Useful for pre-setting'''\n        if not self.fake:\n            try:\n                self.device.write(command)\n            except:\n                print('write operation to Pstat failed')\n        else:\n            print('Pstat: No device. Writing %s to fake Pstat'%command)\n\n    def read(self):\n        if not self.fake:\n            return self.device.read()\n        else:\n            return 42\n\n    def set_measure_range (self,current_limit_in_microamperes):\n        self.write('SENS:CURR:RANG %.6f' % (current_limit_in_microamperes*2e-6))\n\n    def set_current_limit(self,current_limit_in_microamperes):\n        '''set the limit of the current when in the voltage source regime'''\n        self.write('SOUR:VOLT:ILIM %.6f' % (current_limit_in_microamperes*1e-6))\n\n    def beep_tone(self,frequency_in_hz, duration_in_seconds): # fun stuff\n        self.write(':SYSTem:BEEPer %.5f, %.5f'%(frequency_in_hz,duration_in_seconds))\n\n    def play_short_beep(self):\n        self.beep_tone(713,0.1)\n\n    def play_reading_beep(self):\n        self.beep_tone(1413,0.1)\n\n    def play_tune(self):\n        self.beep_tone(523.251, 0.02)\n        self.beep_tone(659.255, 0.02)\n        self.beep_tone(783.991, 0.02)\n\n        # for offtune in range(5):\n        #     for _ in range(3):\n        #         # happy C goes wild:\n        #         self.beep_tone(523.251+ 35*offtune, 0.005)\n        #         self.beep_tone(783.991+ 35*offtune, 0.005)\n        #         self.beep_tone(659.255+ 35*offtune, 0.005)\n        # for offtune in range(5,0,-1):\n        #     for _ in range(3):\n        #         # happy C goes wild:\n        #         self.beep_tone(523.251+ 35*offtune, 0.005)\n        #         self.beep_tone(783.991+ 35*offtune, 0.005)\n        #         self.beep_tone(659.255+ 35*offtune, 0.005)\n        # self.print('call the police.')\n\n\n    def set_voltage(self,voltage_in_volts):  # sets voltage and presets the trigger (1 second transient for now)\n        # ставим напряждение в вольтах на выход пстата и марuм ток. На морде показываем ток. Сам показывается он.\n        # nope, we just set the measurement and trigger it maually.\n\n        self.write('SOUR:VOLT %.3f'%voltage_in_volts)\n\n        # Set the transient meas. duration loop for duration_in_seconds s, no delay (167 ns), saving to buf100\n        # :TRIGger:LOAD \"DurationLoop\"\n        # This command loads a predefined trigger model configuration that makes continuous measurements for a\n        # specified amount of time.\n        # :TRIGger:LOAD \"DurationLoop\", <duration>, <delay>, \"<readingBuffer>\"\n        # 167 ns minimal delay between measurement points\n\n        # after this we just need to turn on the output and to fire the trigger right after that\n\n    def configure_transient_trigger(self,duration_in_seconds, delay_in_seconds):  # duration_in_seconds s measurements into buffer\n\n        self.write(':SENSe:CURRent:NPLCycles 0.01') # change to 0.5 to measure faster. Youll get oscillations! Affects measurement speed.\n\n        self.print('setting up trigger model to DurationLoop: %.2f s'%duration_in_seconds)\n        self.write('TRIG:LOAD \\\"DurationLoop\\\", %.2f, %.4f, \\\"CYKA_BLYAT\\\"' % (duration_in_seconds,delay_in_seconds))  # load trigger model 0.5 us TEMPORARY!\n\n\n    def delete_trace(self):\n        self.write(':TRACe:DELete \\\"CYKA_BLYAT\\\"')\n\n    def trigger_current_transient(self): # starts current transient measurement.\n        print('trigger current transient [NOW] <-')\n        self.write('INIT') # initiate the readings of current WOUD THIS WORK ??? apparently it does\n        self.write('*WAI') # postpone execution of successive commands while this is executed.\n        self.write('OUTP ON')  # keep output on\n\n        # This sets the trigger on time loop\n        # and store the readings in the \\\"CYKA_BLYAT\\\" reading buffer.\n\n        self.write('TRAC:TRIG \\\"CYKA_BLYAT\\\"') # this puts readings on its face / also to the buffer.\n\n    def query_current_transient(self, NPTS: int):# returns the current readings in a string!\n        print('attempting to read %d values from CYKA_BLYAT buffer ++++ P'%NPTS)\n        self.play_reading_beep()\n        self.write('TRAC:DATA? 1, %d, \\\"CYKA_BLYAT\\\", SOUR, READ, REL'%NPTS) # Read the NPTS data points, reading, programmed source, and relative time for each point.\n\n        return self.read()\n\n\n    def output_on(self): # self explanatory\n        self.play_short_beep()  # short beep when pot on\n        self.write('OUTP ON')  # here we turn output on\n        # self.trigger_current_transient()  # and immediately after, start measuring it. For 1 second as for now\n\n\n\n        # #self.write('TRAC:TRIG \\“defbuffer1\\”') # this is for measurement trace. So far not in use.\n        #self.write('TRAC:DATA? 1, 5, \\“defbuffer1\\”, SOUR, READ') # not sure if we need it\n\n    def output_off(self): # self explanatory\n        self.write('OUTP OFF')  # here we turn output off\n        self.play_short_beep()  # short beep when pot on\n        sleep(0.2)\n        self.play_short_beep()  # twice\n\n    def configureCv(self):\n        #self.write(':TRACe:MAKE \\\"CYKA_BLYAT\\\", 10')\n        self.write(':OUTP:SMOD HIMP')  # high impedance output mode, we are dealing with batteries!\n        self.write(':SENSe:CURRent:NPLCycles 0.01') # change to 0.5 to measure faster. Youll get oscillations! Affects measurement speed.\n        self.write('SOUR:FUNC VOLT')  # source voltage!\n        self.write(':SENS:FUNC \\\"CURR\\\"') # measure current\n        self.write('SENS:CURR:RSEN ON')  # 4 WIRE SENSING MODE.\n        self.write('SENSe:COUNt 1') # 1 point to record\n        self.write('SENS:CURR:RANG:AUTO OFF')\n        self.write('SENS:CURR:RANG %.6f'%10e-3)\n        self.print('CV measurement configured.\\n Turning output ON.\\n Jesus Christ saves your battery.')\n        self.write(':OUTP ON')\n\n    def configureCHG(self,absoluteValueOfVoltageLimit: float):\n        self.write(':OUTP:SMOD HIMP') # high impedance output mode, the relay! otherwise no negative curent\n        self.write(':SENS:VOLT:NPLCycles 0.01') # change to 0.5 to measure faster. Youll get oscillations! Affects measurement speed.\n        self.write('SOUR:FUNC CURR') # source current!\n        self.write(':SENS:FUNC \\\"VOLT\\\"') # measure volts\n        self.write('SENS:VOLT:RSEN ON')  # 4 WIRE SENSING MODE. short RE and CE when in 2 electrode configuration.\n        self.write('SENS:VOLT:RANG:AUTO OFF')\n        self.write('SENS:VOLT:RANG %.6f'%(abs(absoluteValueOfVoltageLimit)*1.05))\n        self.write(':SOUR:CURR:VLIM %.4f' % (abs(absoluteValueOfVoltageLimit)*1.05))  # add 5% in case the pstat lies\n        self.write(':SOUR:CURR %.8f' %(-0.000)) # dont interfere in the beginning\n\n\n\n        #todo: set it up on a working machine. the voltage limit of the current source!!!\n\n    def getCHGpoint(self, current_in_amps):\n        # setting the current\n        if current_in_amps > 0:\n            cmd = str(':SOUR:CURR %.8f' % current_in_amps)\n        else:\n            cmd = str(':SOUR:CURR -%.8f' % abs(current_in_amps))\n        self.write(cmd)\n\n        try:\n            voltageString = self.device.query('MEASure:VOLTage:DC?') # 1 point it is supposed to be.\n        except:\n            return float(sin(float(datetime.now().second/10)))\n        try:\n            voltage = float(voltageString)#np.mean(np.array(self.read().split(',')).astype(float))\n        except:\n            voltage = 0\n\n        return voltage\n\n\n    def getCvPoint(self, voltage_in_volts: float, sleeptime: float):\n        \n        self.write(':SOUR:VOLT %.3f' % voltage_in_volts)\n        sleep(sleeptime) # if CV intensity behaves weirdly vs your scan rate, the problem may be in this line.\n        #self.write(':TRAC:CLEAR')\n        try:\n            currentString = self.device.query('MEASure:CURRent:DC?') # 1 point it is supposed to be.\n        except:\n            return (random.randint(0,1000)/1000)\n        #self.write('TRACe:DATA? 1,2, \\\"CYKA_BLYAT\\\", READ, REL, SOUR')# 2, 9')\n        #currentString = self.read() instead of query if you want to wait for a few plc. \n        #print(currentString) # temp\n        current = float(currentString)#np.mean(np.array(self.read().split(',')).astype(float))\n        return current\n\n\n    def TakeCV(self, cv_input:cv.cv, q:Queue):\n        '''take a cv curve with parameters specified in the given cv.cv. plot in the given  plotter'''\n        cvTaken = cv_input\n        # before taking the cv - limit the current!\n        currentLimitInMicroamps = cv_input.currentLimitInMicroamps\n        print(currentLimitInMicroamps,'uA is the limit')\n        print(currentLimitInMicroamps)\n        self.set_measure_range(current_limit_in_microamperes=currentLimitInMicroamps)\n        self.set_current_limit(current_limit_in_microamperes=currentLimitInMicroamps)\n\n        self.q = q # plot cv in the plotter that is given as argument\n\n        # do the electrochemical business here\n        nStepsUp = 128 # n steps in voltages when going up in potentials\n\n        # delay time arithmetics. It took 184.440660 - 0.000225 s to complete 10 scans of 2 volts each.\n        # that makes it 20 volts per 184.440435 s that is 0.10843609211830367 V/S = 108 mV/s,\n        # the MAX rate limited by the matplotlib at my x220. Stupid but I dont have another machine now.\n        # so what is the default delay that it is adding? 0.06 ... 0.11 s per point.\n        # i guess id not plot it at all then, but I have to see the stuff.\n        # using a thread would be a great option\n        # but anyways, if plotted every 5 points the delay is OKAY.\n        # how much to wait every time I get a CV?\n\n        scanWidthInMv = cvTaken.high_voltage_point - cvTaken.low_voltage_point # in mV\n        rateInMvPerSecond = cvTaken.scan_rate # in millivolts per second\n        numberOfPointsInScan = nStepsUp\n\n        delayBetweenPointsInSeconds = scanWidthInMv / rateInMvPerSecond / numberOfPointsInScan # precisely\n\n        # make vector with potentials\n        pot_up_vector = np.linspace(cvTaken.low_voltage_point, cvTaken.high_voltage_point, nStepsUp)\n        pot_down_vector = np.linspace(cvTaken.high_voltage_point, cvTaken.low_voltage_point, nStepsUp)\n        pot_vector = np.concatenate((pot_up_vector,pot_down_vector),axis = 0)\n\n        starttime = datetime.now()  # get current time. start of the cv\n        cvTaken.datetime = str(starttime)\n        cvTaken.voltage = []\n        cvTaken.current = []\n        cvTaken.delayBetweenPointsInSeconds = delayBetweenPointsInSeconds\n\n        # ELECTRICITY ON!\n        self.configureCv()\n        for _ in range(cvTaken.n_cycles):\n\n            for i in range(len(pot_vector)):\n                potential = pot_vector[i]\n                current = self.getCvPoint(voltage_in_volts=potential,sleeptime = delayBetweenPointsInSeconds)\n                reltime = (datetime.now() - starttime).total_seconds()\n                cvTaken.current.append(current)\n                cvTaken.time.append(reltime) # relative time in microseconds\n                cvTaken.voltage.append(potential)\n\n                q.put(cvTaken)\n                # emergency stop break:\n                if self.GlobalInterruptFlag:\n                    self.GlobalInterruptFlag = False\n                    return cvTaken\n\n\n\n\n        self.output_off()\n        return cvTaken\n\n\n    def TakeCV_the_old_way(self, lowPotential: float, highPotential: float, rate: float, filePath:str):\n\n\n        nstepsup = 100\n        dv = (highPotential-lowPotential)/nstepsup # step in voltages assuming nstepsup steps up and 100 down\n        R = rate / 1000 # in volts per second.\n        dt = dv/R\n        print('pstat:cv: dt=%.2e s'% dt)\n        print('pstat:cv: dv=%.2e V' % dv)\n        print('pstat:cv: R=%.2e V/s' % R)\n\n        setVoltages = []  # to be appended\n        measuredCurrents = [] # to be measured and appended\n\n\n        starttime = str(datetime.now())  # get current time. start of the cv\n\n\n\n        self.configureCv()\n        for ctr in range(0,nstepsup,1):\n            voltagetoset = lowPotential+ctr*dv\n            currents = self.getCvPoint(voltage_in_volts=voltagetoset)\n            sleep(dt)\n            setVoltages.append(voltagetoset)\n            #print('cv up, step: %d'%ctr)\n            #print('...voltage: %.2e V' % voltagetoset)\n            #print('...%.2e A'%currents)\n            measuredCurrents.append(currents)\n            # now plotting it irl also\n        \n            self.plotter.plotCvData(setVoltages,measuredCurrents)\n        voltagetoset = highPotential\n        self.set_voltage(voltagetoset)\n\n        for ctr in range(0, nstepsup, 1):\n            voltagetoset = highPotential - ctr * dv\n            self.set_voltage(voltagetoset)\n            currents = self.getCvPoint(voltage_in_volts=voltagetoset)\n            sleep(dt)\n            setVoltages.append(voltagetoset)\n            #print('cv down, step: %d' % ctr)\n            #print('cv: voltage: %.2e V' % voltagetoset)\n            #print('cv%.2e A' %currents)\n            measuredCurrents.append(currents)\n            # now plotting it irl also\n        \n            self.plotter.plotCvData(setVoltages, measuredCurrents)\n        voltagetoset = lowPotential\n        self.set_voltage(voltagetoset)\n\n        self.output_off()\n\n\n        # ------------------------- saving CV to csv file ------------------------------\n        savefile = open(filePath+'.csv', 'w')  # open the file\n        f2w = savefile\n        f2w.write('start, %s\\n' % (str(starttime)))\n        endtime = str(datetime.now())  # get current time. start of the cv\n        f2w.write('end, %s\\n' % (str(endtime)))\n\n        f2w.write('low, %.3f, V\\n' % float(lowPotential))\n        f2w.write('high, %.3f, V\\n' % float(highPotential))\n        f2w.write('rate, %.3f, mV/s\\n' % float(rate))\n\n        for i in range(len(measuredCurrents)):\n            f2w.write(\"%.8e, %.8e,\\n\" % (setVoltages[i], measuredCurrents[i]))\n\n        f2w.close()\n        \n\n\n\n    def TakeCHG(self, chg_input:chg.chg, q: Queue):\n        '''take a chg cycle with parameters specified in the given chg.chg. plot in the given  plotter'''\n        self.chgTaken = chg_input\n\n\n        highVoltageLimit = chg_input.high_voltage_level\n        lowVoltageLimit = chg_input.low_voltage_level\n\n        starttime = datetime.now()  # get current time. start of the cv\n        self.chgTaken.datetime = str(starttime)\n        self.chgTaken.voltage = []\n        self.chgTaken.time = []\n\n        delayBetweenPointsInSeconds = 0.01\n        self.chgTaken.delayBetweenPointsInSeconds = delayBetweenPointsInSeconds # recording as fast as possible, all timing depends on the battery\n\n\n\n        # ELECTRICITY ON!\n\n        print('KEITHLEY IS WORKING.....')\n        self.configureCHG(absoluteValueOfVoltageLimit=max(highVoltageLimit, abs(lowVoltageLimit)))  # go set the knobs there\n\n        self.output_on()\n\n        for _ in range(self.chgTaken.n_cycles):\n            # do chg until the high limit ---- CHG CHG CHG CHG CHG CHG CHG CHG CHG ----\n            measuredVoltage = -65535  # for sure less than the high limit\n\n            print('CHARGING.')\n            while measuredVoltage < highVoltageLimit:\n\n                currentToApply = chg_input.chg_current # charging with the chg current of the passed chg object\n                reltime = (datetime.now() - starttime).total_seconds() # time since the beginning of the experiment\n\n                measuredVoltage = self.getCHGpoint(current_in_amps=currentToApply)\n\n                self.chgTaken.time.append(reltime)\n                self.chgTaken.current.append(currentToApply)\n                self.chgTaken.voltage.append(measuredVoltage)\n                self.chgTaken.filename = 'CHG %.3f [uA] | %d/%d | %.3f / %.3f [V]' % (\n                currentToApply * 1e6, _ + 1, self.chgTaken.n_cycles, measuredVoltage, highVoltageLimit)\n\n\n                # keep pushing data to the queue\n                sleep(delayBetweenPointsInSeconds)\n                q.put(self.chgTaken)\n\n                # emergency stop break:\n                if self.GlobalInterruptFlag:\n                    self.GlobalInterruptFlag = False\n                    return self.chgTaken\n\n\n            print('FULLY CHARGED. DISCHARGING:')\n\n            # then do dcg until the low limit ---- DCG DCG DCG DCG DCG DCG DCG DCG ----\n            self.configureCHG(absoluteValueOfVoltageLimit=max(highVoltageLimit, abs(lowVoltageLimit)))  # highVoltageLimit INDEED! otherwise this crap doesnt discharge\n            measuredVoltage = 65535  # for sure less than the high limit\n\n            while measuredVoltage > lowVoltageLimit:\n\n                currentToApply = chg_input.dcg_current  # discharging with the dcg current of the passed chg object\n                reltime = (datetime.now() - starttime).total_seconds()\n\n                measuredVoltage = self.getCHGpoint(current_in_amps=currentToApply)\n\n                self.chgTaken.time.append(reltime)\n                self.chgTaken.current.append(currentToApply)\n                self.chgTaken.voltage.append(measuredVoltage)\n                sleep(delayBetweenPointsInSeconds)\n                self.chgTaken.filename = 'DCG %.3f [uA] | %d/%d | %.3f / %.3f [V]' % (currentToApply*1e6, _ + 1, self.chgTaken.n_cycles, measuredVoltage, lowVoltageLimit)\n\n                # keep pushing data to the queue\n                sleep(0.01)\n                q.put(self.chgTaken)\n\n\n                # emergency stop break:\n                if self.GlobalInterruptFlag:\n                    self.GlobalInterruptFlag = False\n                    return self.chgTaken\n\n            print('FULLY DISCHARGED.')\n\n        self.output_off()\n        return self.chgTaken\n\n    def ConfigureForTransient(self):\n        #self.write(':TRACe:MAKE \\\"CYKA_BLYAT\\\", 10')\n        self.write('TRAC:MAKE \\\"CYKA_BLYAT\\\", 65535')  # create buffer with n points\n        #self.write('SENSe:CURRent:RANG %.4f'%CURRENTSENSITIVITYLIMIT)\n        self.write(':SENS:FUNC \\\"CURR\\\"') # measure current\n        #self.write(':SOUR:VOLT:ILIM %.4f'%CURRENTSENSITIVITYLIMIT) # 100 mA\n        self.write('SENSe:COUNt 1') # 1 point to record\n        self.write(':OUTP OFF')\n        \n    def TakeChargingTransient(self, potentialToSet: float, durationInSeconds: float, filePath:str):\n        # taking the current transient.\n        # setting the potentialToSet for durationInSeconds\n        # saving the transient in filePath\n        \n         \n        interval = 0.001 # interval between the points in the transient\n        \n        self.print('configure transient trigger')\n        self.configure_transient_trigger(durationInSeconds, interval)\n        self.print('setting voltage %.2f'%potentialToSet)\n        self.set_voltage(potentialToSet)\n        self.trigger_current_transient()\n        sleep(durationInSeconds+1) # one sec\n        self.print('query %d pts from buffer'%durationInSeconds*220)\n        try:\n            transients = self.query_current_transient(durationInSeconds*220) # SOUR, READ, REL 13500 for 60 s -> 255 pts/s -> 1125 pts for 5 s\n        except:\n            self.print('reading transient failed. Launching ICBMs.')\n        self.print('OUTPUT is still on!')\n        \n        dt = str(datetime.now())  # get current time. start of the CT\n        \n        print(transients)\n        \n        # saving those guys to a file\n        current_transient_file = open('%s.chg' %filePath, 'w')  # open the file            \n        #  header\n        current_transient_file.write('Pot_set[V], Pot_meas[V], Current[A], rel_time[s], scan_state\\n')\n        try:\n            # query the current transient\n            # saving current transient\n            vls = transients.split(',')\n            for i in range(0, len(vls), 3):\n                current_transient_file.write(\n                    '%.2f, %.6e, %.6e, %.6e,\\n' % (potentialToSet, float(vls[i]), float(vls[i + 1]), float(vls[i + 2])))\n\n        except:\n            self.print('[   Failed reading current transient.\\n   The warhead is ready for combat.\\n  Launchpad 78\\n  Calculating trajectory...]')\n      \n        # closing the current transient file\n        current_transient_file.write('\\n'+dt+'\\n')\n        current_transient_file.write('dt = %.3e s, t = %.3e s\\n'%(interval,durationInSeconds))\n        current_transient_file.close()                                                      \n\n    #todo: chg/dcg potentiometry with voltage limits\n        \n    def print(self,s:str):\n        print('Keithley 2450-EC >> : %s'%s)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/keithley_pstat.py b/keithley_pstat.py
--- a/keithley_pstat.py	(revision d8815e1aa2c2a356ae007cf49e042b91b6d62df3)
+++ b/keithley_pstat.py	(date 1706625437089)
@@ -39,8 +39,8 @@
         '''create an instance of the pstat object''' # создать объект потенциостата.
         self.rm = rm
         self.connect(model)
-        self.write('*RST')  # ресетнем ка мы его на всякий случай
-        self.write('*IDN?') # и спросим, как его зовут
+        self.write('*RST')  # always reset the thing
+        self.write('*IDN?') # and ask whats your name
         response = self.read()
         self.play_tune()
         self.write('DISP:SCR SWIPE_GRAP')
@@ -92,6 +92,7 @@
                 self.device.write(command)
             except:
                 print('write operation to Pstat failed')
+                self.fake = True
         else:
             print('Pstat: No device. Writing %s to fake Pstat'%command)
 
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.9\" project-jdk-type=\"Python SDK\" />\n  <component name=\"PyCharmProfessionalAdvertiser\">\n    <option name=\"shown\" value=\"true\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision d8815e1aa2c2a356ae007cf49e042b91b6d62df3)
+++ b/.idea/misc.xml	(date 1706625437577)
@@ -1,5 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
+  <component name="Black">
+    <option name="sdkName" value="Python 3.9" />
+  </component>
   <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9" project-jdk-type="Python SDK" />
   <component name="PyCharmProfessionalAdvertiser">
     <option name="shown" value="true" />
