Index: communication.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>'''\n    This is the communicator class that unifies the communication between all our devices.\n    Devices are fields of the communicator. Once device is connected, its methods can be applied.\n    Looks like we need to inherit devices from the visa.resource_pyclass and use proper constructors.\n    For that we will need a real programmer who knows what they are doing.\n    A suggestion to separate this module into small modules to import them separately, but for now, we\n    stick to this library-like file.\n'''\n\nimport pyvisa as visa\n\nfrom time import sleep #time-dependent business for IV curves and time-constants\ninterval = 0.01 # an interval in seconds that is waited whenever a command is sent to the Osilla's X200 SMU.\n# Can be made a little shorter, but Osilla is unpredictable often.\n\nimport lock_in  # lock in amplifier class.\nimport bh_15   # field controller class\nimport keithley_pstat  # potentiostat keithley model 2450 source meter\nimport agilent_53181a  # frequency counter class.\nimport Plotter\nimport emres_right_hand\n\nclass communicator(object):\n    rm = 0 # no resource manager for beginning\n    lockin = lock_in.lockin\n    field_controller = bh_15.bh_15\n    keithley_pstat = keithley_pstat.pstat\n    frequency_counter = agilent_53181a.agilent_frequency_counter\n    right_hand = emres_right_hand.emres_right_hand\n\n    devices_list = [lockin,field_controller,keithley_pstat,frequency_counter] # to be expanded\n\n    # for the beginning only two devices. then we may expand. Gaussmeter is a must, frequency counter is desirable too\n\n    def __init__(self, backend, cvPlotter: Plotter.Plotter): #  BUGS!!!!! <---------- the fucking plotter, noone really needs it at this point.\n        '''The constructor of the communicator class.'''\n        # visa.log_to_screen() #here we initialize the communicator. But there is nothing really to initialize logging is temporary\n        backend = '@py'# for PyVISA-py backend, '' for NIVISA backend\n        self.rm = visa.ResourceManager('%s'%backend) # forget about Windows for a while.\n        # populating devices:\n        self.lockin = lock_in.lockin(rm = self.rm, model = '810') # creating lia, that easy.\n        self.field_controller = bh_15.bh_15(rm = self.rm, model = 'BH-15') # creating field controller. that easy.\n        self.keithley_pstat = keithley_pstat.pstat(rm = self.rm, model = '2450', plotter=cvPlotter) # creating pstat. That easy BUGS!!!!! <---------- the fucking plotter, noone really needs it at this point.\n        self.frequency_counter = agilent_53181a.agilent_frequency_counter(rm=self.rm, model = '53181')\n        self.right_hand = emres_right_hand.emres_right_hand()\n\n\n    def list_devices(self):\n        '''list all devices, no matter available or not'''\n        list_of_resources = (self.rm.list_resources())\n        print(self.devices_list)\n        # for device in self.devices_list:\n        #     list_of_connected_devices.append(device)\n        #     device.print(device.address,'>')\n        return self.devices_list\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass old_communicator (object):\n    '''Our lab is a village with neighbors. There is a very communicative guy that knows all names and all addresses, the communicator.\n    This person knows good manners and has found a common language to all his neighbors.\n    When new neighbors move in, the person writes down their names and numbers in a list.\n    So far there are not so many neighbors so the communicator can remember all names\n    It is not meant to be like this forever though.\n    We will observe with excitement as our small village expands to the gulf of Isaak and one day to the everfrost of XQ'''\n    rm = 0 # resource manager. '@py' for PyVISA-py backend. Sent as parameter to the constructor,\n\n    #now we have just four devices but we plan on expanding this list\n\n    lockin = 0               # SR860 LIA is a Visa.instrument     | TCPIP\n    sourcemeter = 0          # Keithley 2611A SMU                 | TCPIP\n    xtralien = 0             # Xtralien X200 SMU by Osilla        | Serial TODO: would be nice to have type declaration here. Emre?\n    scope = 0                # Lyra's Tektronix scope             | USB  Using it to get the tune picture\n    agilent = 0              # Lyra's Agilent Frequency Counter   | GPIB\n    field_controller = 0     # B-H 15 Field controller by Bruker  | GPIB\n    gaussmeter = 0           # ER 035 M NMR Gaussmeter by Bruker  | Serial\n    keithley_potentiostat = 0# Keithley 2450 source-measure unit. | GPIB\n    t_sensor = 0   # Oxford temperature controller.       | GPIB\n\n    '''Here come some labels aka flags. \n    The following fields needed when we want to use a fancy GUI which indicates states of devices in real time.\n    For example, if the lock-in is connected to the computer, a green light may go on on the gui.'''\n\n    lockin_status =      'dis'  # also possible 'con' 'ext' 'int' and 'dua'. These vars are no serious, mainly for the GUI\n    sourcemeter_status = 'dis'  # they can be fields of the corresponding objects but im not sure how to implement that\n    xtralien_status =    'dis'  #  When we separate the modules, to make a field 'status' for each device. Its easier to track the statuses of the setup this way.\n    scope_status =       'dis'\n    agilent_status =     'dis'\n    # field_controller_status = 'dis'\n\n\n    def __init__(self, backend):\n        '''The constructor of the communicator class.'''\n        visa.log_to_screen() #here we initialize the communicator. But there is nothing really to initialize logging is temporary\n        # backend = '@py' for PyVISA-py backend, '' for NIVISA backend\n        self.rm = visa.ResourceManager('%s'%backend) # forget about Windows for a while.\n        pass\n\n    def list_resources(self):\n        '''communicator can list connected resources but so far it is just the PyVisa code.\n        Visa is bad at listing GPIB and USB devices as well as TCPIP devices (there are billions addresses to go through!)\n        What we want here is to try accessing all known resources on all known protocols,\n        More precisely, you have listed here some devices, say, 18 devices in total. The lock-ins, the Keithley and so on.\n        Then you run this script on a new machine. Script tries to find all the 18 devices and to perform a hand-shake\n        with each of them. '''\n        listres = self.rm.list_resources() #this is lame!\n        print(listres)\n        return listres\n\n    '''Next the script is divided into sets of commands, \n    because the programmer was not familiar with classes at that point.'''\n\n    def handshake(self, address):\n        '''shake hands with a device on address address. Address i8s a string, Send IDN. Print response.'''\n        self.dummy = self.rm.get_instrument(address)\n        try:\n            self.dummy.write(\"*IDN?\")\n            response = self.dummy.read()\n            print('%s : %s'%(address,response))\n        except:\n            print('handshake to %s failed'%str(address))\n\n\n    '''----------------------------- BH15 Field Controller COMMANDS --------------------------------------------'''\n    def connect_to_field_controller(self):\n        addr_string = 'GPIB0::8::INSTR'  # pad 8\n        self.field_controller = self.rm.get_instrument(addr_string, write_termination = '\\r')\n        print(self.field_controller)\n        #getting led status of BH15:\n\n    def field_controller_device_clear(self):\n        mnemonic = \"SDC\"\n        command = mnemonic\n        print(self.field_controller.write(command))\n    def field_controller_read_blank(self):\n        self.field_controller.read()\n\n    def field_controller_get_led_status(self):\n        try:\n            print(self.field_controller.write('LE'))\n            response = self.field_controller.read()\n            print(response)\n            if ('1' in str(response)):\n                print('overload')\n            if ('2' in str(response)):\n                print('thermostat')\n            if ('3' in str(response)):\n                print('ext. sweep')\n            if ('4' in str(response)):\n                print('remote')\n\n        except:\n            print('LE query to BH15 failed')\n\n    def goremote(self):\n        mnemonic = \"CO\"\n        command = mnemonic\n        print(self.field_controller.write(command))\n\n    def field_controller_set_center_field(self,field_):\n        field = str(field_)\n        mnemonic = \"CF\"\n        command = mnemonic + field\n        print(command)\n        print(self.field_controller.write(command))\n\n    def reset_field_controller(self):\n        mnemonic = \"DCL\"\n        command = mnemonic\n        print(self.field_controller.write(command))\n\n    def set_operating_mode_of_field_controller(self,mode_):\n        '''0: basic field control\n           1: with repetitive auto sweep\n           3: with external address advance\n           4: reserved\n           5: basic measure mode\n           6: hi-res measure mode'''\n\n        mode = str(mode_)\n        mnemonic = \"MO\"\n        command = mnemonic + mode\n        print('sending %s to BH15'%command)\n        print(self.field_controller.write(command))\n\n    def curse_BH15(self,command_):\n        print(self.field_controller.write(command_))\n\n    def talk_to_BH15(self, command_): #this returns a value (string or whatever)\n        print(self.field_controller.write(command_))\n        response = (self.field_controller.read())\n        print(response)\n        return response\n\n    def get_measured_field(self):\n        query = \"FV\"\n        #self.field_controller.read_termination = '\\0'\n        print(self.field_controller.query(query))\n\n    def get_interlock_lines(self):\n        query = \"IL\"\n        self.field_controller.write(query)\n        print(self.field_controller.read())\n\n    def field_controller_unlisten(self):\n        query = \"UNL\"\n        print(self.field_controller.write(query))\n\n    def field_controller_untalk(self):\n        cmnd= \"UNT\"\n        print(self.field_controller.write(cmnd))\n\n    def gotolocal(self):\n        query = \"GTL\"\n        print(self.field_controller.write(query))\n\n    '''----------------------------------------LOCK-IN COMMANDS-------------------------------------------------'''\n\n    def connect_to_lockin(self, model): # constructor for the lock-in amplifier.\n    # TODO:  take a pencil and a piece of paper. Go around the lab, Write down the devices. Implement here, we have 510, 810, 860 lockins.\n    # We might need machine files at this point. But it is a different story.\n        if (model == 860):\n            addr_string = 'TCPIP0::192.168.1.51::inst0::INSTR'\n            print('Hall')\n        if (model == 810):\n            addr_string = 'GPIB0::9::INSTR' #pad 9\n            print('SR 810 on lyra. Connection OK.')\n        if (model == 830):\n            addr_string = ''\n            print('isaak. GIVE ME THE GPIB ADDRESS!')\n\n\n        try:\n            self.lockin = self.rm.get_instrument(addr_string) # connecting via lan to the lockin.\n            # Device's IP might change, if you cannot connect you might need to enter the IP here.\n            self.lockin.write(\"*IDN?\") # if connected this should return the lockin's id\n            response = self.lockin.read()\n            print(response)\n            self.lockinstatus = 'con' #tracking of the status. Good for bulletproof scripts\n            #would be cool to inherit the lockin from visa.instrument and add lockinstatus as a lockin's field, but im ok like this\n            #self.moveLockinToTheHallmode() # a default state of the lock-in is the hall-effect measurement. It makes sense to change it to CW EPR mode\n            return 'OK:\\n'+response #if ok return lockin's id\n        except:\n            self.lockinstatus = 'dis'\n            return'failed to connect to LOCK-IN!'\n\n    def writeLockin(self, lines): # to make things easier we can call this to write many successive commands\n        for line in lines:\n            self.lockin.write(line)\n\n    def setLockinVoltage(self, voltage_in_volts: float):\n        '''sets amplitude in V for sin out'''\n        amplitudeForLockin = voltage_in_volts * 1000  # volts to millivolts conversion\n        self.lockin.write('SLVL ' + str(amplitudeForLockin) + ' MV')\n        return 0\n\n    def getLockinR(self):\n        # self.lockin.write('GAUT DAT3')  # autoscale the R channel\n\n        self.lockin.write('OUTP? 2')  # request for R channel\n        voltage = float(self.lockin.read())  # read the lockin response in volts\n        return voltage\n\n    def get_lockin_voltage(self, channel: str):\n        parameter = 2  # default request is R channel data\n\n        if channel == 'r':\n            parameter = 2\n        if channel == 'x':\n            parameter = 0  # request for X channel\n        if channel == 'y':\n            parameter = 1  # request for Y channel\n        if channel == 't':\n            parameter = 3  # request for THETA channel\n\n        self.lockin.write('OUTP? %d' % parameter)  # request for data at #parameter channel\n        current = float(self.lockin.read())  # read the lockin response in amps\n        return current\n\n    def setLockinFrequency(self, frequency_in_hz: float):  # set the internal oscillator frequency in Hz\n        lkin = self.lockin\n        lkin.write('FREQ %f' % frequency_in_hz)  # set frequency\n\n    # return str(lkin.read()) #careful! might be buggy!\n\n    def set_lockin_time_constant(self, CODE: int):\n        lockin = self.lockin\n        lockin.write('OFLT %d' % CODE);  # Go to new time constant with code CODE\n\n    def set_lockin_phase(self, phase: float):\n        '''careful with commas in the float type. You might want to use int instead.'''\n        self.lockin.write('PHAS %d DEG' % phase)\n\n    def get_lockin_phase(self):\n        self.lockin.write('PHAS?')\n        return float(self.lockin.read())\n\n    def get_time_constant(self, getnext):\n        lockin = self.lockin\n        lockin.write('OFLT?');  # what is your time constant in codes?\n\n        tc = int(lockin.read())  # read the response\n\n        # decode tc from code to seconds\n        def times(tm):\n            return {\n                0: 0.000001,  # 1 us\n                1: 0.000003,\n                2: 0.00001,\n                3: 0.00003,\n                4: 0.0001,\n                5: 0.0003,\n                6: 0.001,\n                7: 0.003,\n                8: 0.01,\n                9: 0.03,\n                10: 0.1,\n                11: 0.3,\n                12: 1,\n                13: 3,\n                14: 10,\n                15: 30,\n                16: 100,  # 100 s\n            }.get(tm, -1)  # default value to return is -1 that means smth went wrong and threw an error\n\n        if getnext == 'next':  # if next TC is required.\n            return times(\n                tc + 1)  # returns TC+1 in seconds, i.e. next largest time constant. Note the actual TC is not changed here\n        else:\n            return times(tc)  # by default return current TC\n\n    def set_lockin_sensitivity(self, code: int):\n        '''I could have done it human-friendly, but sensitivity setting itself is alien.'''\n        lockin = self.lockin\n        lockin.write('SCAL %d' % code)\n\n    def moveLockinToTheIVmode(self):  # a brave attempt to implement an AC IV measurement\n        '''\n            here we send commands to the lockin so that it goes to IV mode:\n            Time constant: TC = 100 us\n            Reference source: internal\n            Internal frequency: 20KHz\n            Input Range: 1V\n        '''\n        self.writeLockin([\n            'OFLT 4',  # set TC to 100 us\n            'FREQ 5 KHZ',  # set frequency to 5khz\n            'RSRC 0',  # detection to the single mode\n            'IRNG 1V',  # input range to 1v\n            'REFM DIF',  # output to difference\n        ])\n\n    def moveLockinToCurrentMeasurementMode(self):  # this is used within the Hall mode when current is measured\n        ''' current input, single detection mode, mind the range and time constant '''\n        self.lockinstatus = 'int'\n\n        lockin = self.lockin\n\n        lockin.write('IRNG 1V')  # input range to 1v\n        lockin.write('OFLT 4')  # set TC to 100 us\n        lockin.write('RSRC 0')  # detection to the internal mode\n        self.lockinstatus = 'int'\n        lockin.write('REFM COM')  # output to common\n        lockin.write('IVMD CURRENT')  # input to current\n\n\n    def moveLockinToTheHallmode(self):  # this is needed just to check that all settings are fine. might be called with initialization of the lock-in.\n        '''\n        here we send commands to the lockin so that it goes to Hall mode:\n        Time constant: TC = 1 s\n        Reference source: dual\n        Input Range: 1 V\n        '''\n        self.writeLockin([\n            'OFLT 9',  # set TC to 300 ms?\n            'ISRC A-B',  # input mode to difference\n            'IVMD VOLT',  # input to voltage to avoid spikes, thanks Naitik and Dasha\n            'IRNG 1V',  # input range to 1v\n            'REFM COM',  # output to common\n        ])\n        sleep(1)  # let voltage drop to normal value with a short time constant first.\n        self.writeLockin([\n            'OFLT 14',  # set TC to 10 s but for the future, let user choose in Hall module. We really need fields for that all. I am doing it wrong.\n            'RSRC 2',  # detection to the dual mode\n        ])\n        self.lockinstatus = 'dua'\n\n    def autophase(self):  # set autophase, wait 3TC until the signal is relaxed.\n\n        lockin = self.lockin\n        lockin.write('APHS');  # first set autophase\n        tc = self.get_time_constant(\n            argument='next')  # then get the time constant which is approx 3 times larger than the current time constant\n        self.wait_ms(tc * 1000)\n        self.lockin.write('GAUT DAT3')  # rescale the R channel just to see it better on the LIA's face\n\n        return 'Phase corrected, waited 3TC = %d s to stabilize' % tc\n\n    def checkLocked(self):  # useless junk but commands here are useful\n\n        lockin = self.lockin\n        lockin.write('FREQINT?')\n        status_string = 'INT: %.3f Hz' % float(lockin.read())\n        lockin.write('FREQEXT?')\n        status_string += '\\nEXT: %.3f Hz' % float(lockin.read())\n        lockin.write('FREQDET?')\n        status_string += '\\nDET: %.3f Hz' % float(lockin.read())\n        return status_string\n\n    def get_freqdet(self):  # gives the detection frequency\n        self.lockin.write('FREQDET?')\n        return float(self.lockin.read())\n\n    '''--------------------------------------------Tektronix Scope Commands -------------------------------------'''\n\n    def connect_to_scope(self):\n        ''' constructor for the scope. TODO: need more rights to get access to USB.\n        Need rights. Modify the 99-ni... file and restart udev. have a look here:\n        https://stackoverflow.com/questions/52256123/unable-to-get-full-visa-address-that-includes-the-serial-number\n        we will need to use the system interpreter. If so, installing packages is not possible for non-roots.\n        When using vitrual eivironment, accessing gpib can be troublesome.\n        '''\n        sleep(0.1)\n        #self.scope = self.rm.get_instrument('USB0::2733::281::030031632::0::INSTR') # Hall-setup R&S scope\n        try:\n            self.scope.close()\n        except:\n            print('no scope to close, but its okay.')\n#        self.scope = self.rm.get_instrument('USB0::1689::872::C030318::0::INSTR')  # standard tektronix scope\n        try:\n            self.scope = self.rm.get_instrument('USB0::1689::929::C011897::0::INSTR') #LYRA tds 2002C scope\n            sleep(0.1)\n            self.scope.write('*IDN?')\n            sleep(0.1)\n            response = self.scope.read()\n            print('connection to the scope OK:\\n' + response)  # if ok return scope's id)\n        except:\n            print('ERROR: failed connecting to scope')\n#        except:\n #           self.scopestatus = 'dis'\n  #          return 'failed to connect to the scope!'\n\n    def get_tunepicture(self):\n        '''\n        this method returns a waveform of the channel 1 of the scope.\n        The connection to the scope is specified in the connect_to_scope method\n        The commmands are sent in ASCII encoding via GPIB or USB interface.\n\n        1. configure the data format and waveform locations\n        2. request a waveform of Ch1'''\n\n        self.scope.write(\"DATA:SOURCE CH1\")#choose the source of data\n        self.scope.write(\"DATa:ENCdg \") #choose the encoding\n        #DATa: WIDth #specify number of bytes\n        preamble = self.scope.query('WFMPRE?') #transfers waveform preampbe information\n        curve = self.scope.query('CURVE?') #transfers the waveform data\n        #initially we want the hardcopy through the usb port\n        hardcopy_prt = self.scope.query('HARDCOPY:PORT?')\n        print(hardcopy_prt)\n\n\n        sleep(1)\n        # Hall-setup R&S, 1 chan time trace:\n        #curve = self.scope.query('FORM ASC;:CHAN1:DATA?')\n\n        # standard Tektronix scope:\n        #self.scope.write(\"DATA:SOURCE CH1\")\n        print(''\n              'R                eprequesting tunepicture from scope Channel 1')\n        #curve = self.scope.query('CURVe?') # for tektronix\n        print(preamble)\n        return curve\n\n\n    '''-------------------------------------- Agilent Frequency Counter Commands --------------------------------'''\n\n    def connect_to_agilent(self):\n        try:\n            self.agilent = self.rm.get_instrument('GPIB0::3::INSTR') #todo: learn about the agilent's gpib address and hook it up\n            print('connecting to Agilent Frequency counter...')\n            self.agilent.write('*RST') #connect and reset the counter\n            print('connection to the frequency counter OK:\\n' + self.agilent.query('*IDN?')) # if ok return counter's id\n        except:\n            self.agilentstatus = 'dis'\n            print('ERROR: failed to connect to the Agilent frequency counter!')\n\n    def agilent_get_MW_frequency(self):\n        frequency = 0\n        #sleep(5)\n        self.agilent.write('*CLS') #clearing the errors\n        self.agilent.write('*SRE 0')  # service request enable register clear\n        self.agilent.write('*ESE 0')  # event status enable register clear\n        self.agilent.write(':STAT:PRES')  # prepare for operations and questionable sreuctures\n        self.agilent.write(\":FUNC 'FREQ 2'\")  # measuring frequency on CH2\n        self.agilent.write(\":FREQ:ARM:STAR:SOUR IMM\") #i took that from the agilent's manual. Not completely sure what it does\n        self.agilent.write(\":FREQ:ARM:STOP:SOUR TIM\")\n        self.agilent.write(\":FREQ:ARM:STOP:TIM .100\") #0.1 s gate time\n        self.agilent.write('READ:FREQ?')  # finally reading the frequency\n        frequency = float(self.agilent.read())\n        print(frequency)\n\n        return frequency #unless communication established, return this value. Temporary.\n\n    '''---------------------------------------- XTRALIEN COMMANDS -----------------------------------------------'''\n\n    def connect_to_xtralien(self):\n        ''' the xtralien likes to jump between the virtual ports so you never know where is it going to be\n            connected to next time. Never saw ACM3 so I assume 2 is enough '''\n        # TODO: finish it when you can talk to the x200\n        import serial\n        devices = [\n            '/dev/ttyACM0',\n            '/dev/ttyACM1',\n            '/dev/ttyACM2',\n        ]\n\n        for device in devices:\n            try:\n                self.xtralien = serial.Serial(device, timeout=1)\n                self.xtralienstatus = 'con'\n                print(self.xtralienstatus)\n                self.set_xtralien_shutter(0) # shutter is a good use for the Van-der-Pauw measurement. To be continued..\n                return 'OK: ' + self.xtralien.name\n            except:\n                continue\n\n        # NOTE: если хотя бы один девайс сработал, то функция закончила выполнение.\n\n        return 'failed to connect to Xtralien SMU'\n\n\n    def set_pin(self, mode: str, pin: int): # super useful stuff.\n        ''' sets pin number pin to a mode mode.\n            There is an arduino inside that Xtralien board and you can talk to it, too.\n            Syntax is standard (LOW, HIGH)'''\n\n        string = 'io set %s %d' % (mode, pin)\n        bytestring = string.encode('ASCII')\n        sleep(interval) # this is annoying but you have to do this in case you want to use Visa for talking\n        self.xtralien.write('io set %s %d' % (mode, pin))\n\n    def set_xtralien_voltage(self, source, voltage, currentrange):\n        '''\n        sets output of one of the source\n        :param source: 1 or 2\n        :param voltage: float Volts\n\n        :param currentrange selects among the applied current ranges:\n        1   100 mA\n        2   10 mA\n        3   1 mA\n        4   10 uA\n        '''\n        # setting the range of current first, you don't want to burn it\n        msg = 'smu%d set range %d'%(source,currentrange)\n        bytemsg = msg.encode('ASCII')\n        sleep(interval)\n        self.xtralien.write(bytemsg)\n        #here setting the voltage at the output safely\n        msg = 'smu%d set voltage %f'%(source,voltage)\n        bytemsg = str.encode('ASCII')\n        sleep(interval)\n        self.xtralien.write(bytemsg)\n\n    def set_xtralien_averaging(self,source,N): # average over N measurements before returning result\n        string = 'smu%d set filter %d'%(source,N)\n        bytestring = string.encode('ASCII')\n        #print(bytestring)\n        self.xtralien.write(bytestring)\n        sleep(interval)\n\n    def get_xtralien_voltage(self, source):\n        '''returns voltage of the corresponding source in volts\n        :returns float'''\n\n        #first set the averaging to lets say 10\n        self.set_xtralien_averaging(source, 10) # okay. here we set 10 averages. might need to wait longer.\n        # This is temporary\n\n        string = 'smu%d measurev' % source\n        bytestring = string.encode('ASCII')\n        #print(bytestring)\n        self.xtralien.write(bytestring)\n        sleep(10*interval)\n        response = self.xtralien.read_until('\\n')\n        #print(response)\n        return float(response.decode('ASCII')[1:-2])\n\n    def get_xtralien_current(self,source): # returns current in Amps, format: FLOAT\n\n        # first set the averaging to lets say 10\n        self.set_xtralien_averaging(source, 10)  # okay. here we set 10 averages. might need to wait longer\n\n        string = 'smu%d measurei'%source\n        bytestring = string.encode('ASCII')\n        #print(bytestring)\n        self.xtralien.write(bytestring)\n        sleep(interval)\n        response = self.xtralien.read_until('\\n')\n        return float(response.decode('ASCII')[1:-2])\n\n    def set_xtralien_shutter(self,state: bool):\n        '''writes STATE to the D12 pin,'''\n        #string = 'io digital write %d %d'%(12, state)\n        string = 'shutter %d'%state\n        bytestring = string.encode('ASCII')\n        print(bytestring)\n        sleep(interval)\n        self.xtralien.write(bytestring)\n        return 'shutter set to %s'%state\n\n    def move_xtralien_to(self,state: str):\n        if state == 'mnop':\n            sleep(interval)\n            self.set_xtralien_shutter(False) # for mnop van-der-pauw measurements relay is off\n        if state == 'nopm':\n            sleep(interval)\n            self.set_xtralien_shutter(True) # for nopm vdp meas relay needs to be on\n        else:\n            return ('wrong argument')\n\n    def set_xtralien_osr(self, target: str, value: int):\n        string = '%s set osr %d'%(target,value)  # herewe set OSR to a target\n        bytestring = string.encode('ASCII')\n        self.xtralien.write(bytestring)\n        sleep(interval)\n\n    def xtralien_interact(self, s):\n        self.xtralien.write(s.encode('ASCII'))\n        sleep(interval)\n        response = self.xtralien.read_until('\\n').decode('ASCII')\n        sleep(interval)\n        return response\n\n    def get_xtralien_osr(self):\n        pairs = [\n            ('SMU1 OSR', 'smu1 get osr'),\n            ('SMU2 OSR', 'smu2 get osr'),\n            ('Vsense1 OSR', 'vsense1 get osr'),\n            ('Vsense2 OSR', 'vsense2 get osr'),\n        ]\n\n        for (name, command) in pairs:\n            print('%s %s' % (name, self.xtralien_interact(command)))\n\n\n    def get_xtralien_vsense(self, sense: int, N: int): # measures N times at Vsense[sense] and returns voltage in Volts, format: FLOAT\n\n      #TODO: look carefully at this section!\n\n        string = 'vsense%d measure %d'%(sense,N) #here vsense measures N values in a row, giving an array\n        bytestring = string.encode('ASCII')\n        self.xtralien.write(bytestring)\n        sleep(interval*2*N)\n        response = self.xtralien.read_until('\\n').decode('ASCII')[1:-2].split(';')\n        '''TEMOPORARY!'''\n        print('----- collected voltages: -----')\n        print (response)\n        #now we have the array of data and doing the averaging by hand\n        sumup_voltage=0\n        for k in response:\n            sumup_voltage += float(k)\n            #print('current > %s, sumup > %.3f\\n'%(k,sumup_voltage))\n        averaged_voltage = sumup_voltage/N\n        return averaged_voltage\n\n    '''---------------------------------------- KEITHLEY COMMANDS -----------------------------------------------'''\n    def connect_to_sourcemeter(self):\n        try:\n            self.sourcemeter = self.rm.get_instrument('TCPIP0::192.168.1.20::inst0::INSTR') #Address might change, then change it here also\n            self.sourcemeter.write(\"*IDN?\")\n            response = self.sourcemeter.read()\n            self.sourcemeter.write(\"smua.reset()\") # when connected, all reset\n            self.sourcemeterstatus = 'con'\n            return 'OK:\\n'+response + ',sourcemeter reset.'#if ok return smu's idn and reset it\n        except:\n            self.sourcemeterstatus = 'dis'\n            return 'failed to connect to Keithley!\\n'\n\n    def reset_sourcemeter(self): # a customized reset method, suitable for organics\n        try:\n            self.sourcemeter.write(\"smua.reset()\")  # reset the source-meter\n            self.sourcemeter.write(\"smua.source.limiti = 1000e-3\")  # limit the current\n            self.sourcemeter.write(\"smua.source.func = smua.OUTPUT_DCVOLTS\")  # output volts\n            self.sourcemeter.write(\"smua.source.rangev = 20\")  # output range 20 V\n            self.sourcemeter.write(\"smua.source.levelv = 0\")  # output value 0 volts\n        except:\n            return('could not reset sourcemeter. check connection')\n\n    def set_voltage_sourcemeter(self, amplitude_in_volts):\n        self.sourcemeter.write(\"smua.source.levelv = \" + str(amplitude_in_volts))  # output value for voltage is set, keithley understands volts\n        self.sourcemeter.write(\"smua.source.output =smua.OUTPUT_ON\")  # output is on!\n        return 'set voltage '+str(amplitude_in_volts)+ 'V'\n\n    def wait_ms(self,time_in_ms):\n        sleep(float(time_in_ms / 1000)) #sleep method eats seconds\n        return 'waited'+str(time_in_ms)+' ms'\n\n    def get_current_sourcemeter(self, number_of_averages, delay_in_ms):\n        tempCurrents = []\n        for counter in range (number_of_averages):\n            self.wait_ms(delay_in_ms)\n            self.sourcemeter.write(\"currenta, voltagea = smua.measure.iv()\") #writing command to read current\n            tempCurrents.append(float(self.sourcemeter.ask(\"print(currenta)\"))) #creating an array of currents\n        current_value = float(sum(tempCurrents))/len(tempCurrents) #average value of temporary currents\n        return current_value\n\n    def shutdown_output_sourcemeter(self):\n        self.sourcemeter.write(\"smua.source.output=smua.OUTPUT_OFF\")\n        return 0\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n  #      f2w = open('haram.txt','w')  # create and open a file for writing\n    \n #       c = self.machine.process_text('WAKEUPNEO', replace_char='X') #KLOWCYJVF CFAUPBURPFRHLTY YWZABSLJHLSOQLCLXYGV\n#        f2w.write('%s\\n'%c)\n\n     #   f2w.write('%s\\n'%c)\n    #    c = self.machine.process_text('thebodycannotlivewithoutthemind', replace_char='X') #KLOWCYJVF CFAUPBURPFRHLTY YWZABSLJHLSOQLCLXYGV\n   #     self.machine.set_display('EAC')\n  #      msg_key = self.machine.process_text('RST')\n        \n    #    f2w.write('%s\\n'%c)\n   #     c = self.machine.process_text('mindyourfreedom', replace_char='X') #KLOWCYJVF CFAUPBURPFRHLTY YWZABSLJHLSOQLCLXYGV\n  #      self.machine.set_display('EAC')\n #       msg_key = self.machine.process_text('RST')\n        \n   #     f2w.write('%s\\n'%c)\n  #      c = self.machine.process_text('whatdoallmenwithpowerwant?Morepower', replace_char='X') #KLOWCYJVF CFAUPBURPFRHLTY YWZABSLJHLSOQLCLXYGV\n #       self.machine.set_display('EAC')\n#        msg_key = self.machine.process_text('RST')\n        \n        #f2w.write('%s\\n'%c)\n        #c = self.machine.process_text('perhapsweareaskingthewrongquestion', replace_char='X') #KLOWCYJVF CFAUPBURPFRHLTY YWZABSLJHLSOQLCLXYGV\n       # self.machine.set_display('EAC')\n      #  msg_key = self.machine.process_text('RST')\n        \n   #     f2w.write('%s\\n'%c)\n    #    c = self.machine.process_text('youhaveaproblemwithauthority,Mr.Anderson.Youbelieveyouarespecial,thatsomehowtherulesdonotapplytoyou.Obviously,youaremistaken', replace_char='X') #KLOWCYJVF CFAUPBURPFRHLTY YWZABSLJHLSOQLCLXYGV\n     #   self.machine.set_display('EAC')\n  #      msg_key = self.machine.process_text('RST')\n        \n #       f2w.write('%s\\n'%c)\n\n    \n#        f2w.close()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/communication.py b/communication.py
--- a/communication.py	(revision 296ed967c938606051c88196226f4c1da5367d78)
+++ b/communication.py	(date 1661986236642)
@@ -22,7 +22,7 @@
 
 class communicator(object):
     rm = 0 # no resource manager for beginning
-    lockin = lock_in.lockin
+    lockin = lock_in.lockin # just a type definition
     field_controller = bh_15.bh_15
     keithley_pstat = keithley_pstat.pstat
     frequency_counter = agilent_53181a.agilent_frequency_counter
Index: lock_in.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>'''communication to the lock-in amplifier.\nWritten by Ilia Kulikov on 26/10/20\nilia.kulikov@fu-berlin.de'''\n\nimport pyvisa as visa\n\nclass lockin (object):\n    type = 'lock-in'\n    model = 810                   # default model is 810 that is the lock-in at Lyra\n    address = 'GPIB0::9::INSTR'   # and this is its GPIB address\n    device = 0                    # pyvisa device that is populated with the constructor\n    rm = 0                        # visa resource manager\n    fake = False                  # use simulated outputs. Used for testing outside the lab.\n\n    def __init__(self, rm: visa.ResourceManager, model: str): # when create a lia you'd better have a resource manager already working\n        '''create an instance of the lock-in amplifier object'''\n        self.rm = rm\n        self.connect(model)\n\n    def write(self, command):\n        '''write data to lock-in, many lines can be accepted as an argument. Useful for pre-setting'''\n        if not self.fake:\n            try:\n                self.device.write(command)\n            except:\n                print('write operation to lock-in failed')\n        else:\n            print('Lock-in: No device. Writing %s to fake lock-in'%command)  # when device is fake, write to console\n\n    def read(self):\n        if not self.fake:\n            return(self.device.read())\n        else:\n            return(3.1415926353897932384626433832795028841971693993751058209749445978230164)\n\n\n    def connect(self,model):\n        '''connect to lock-in model model. Figure out its address by model number and then connect'''\n        if (model == 860):\n            self.address = 'TCPIP0::192.168.1.51::inst0::INSTR'\n            print('Hall')\n        if (model == 810):\n            self.address = 'GPIB0::9::INSTR' # GPIB pad 9, the 810 on Lyra\n            print('SR 810 on lyra.')\n        if (model == 830):\n            self.address = ''\n            print('isaak. GIVE ME THE GPIB ADDRESS!')\n        # by model we got the address\n        try:\n            self.device = self.rm.open_resource(self.address)\n            self.write(\"*IDN?\") # send an IDN query\n            self.status = 'con'\n            print('connected to lock-in: %s'%self.device.read()) # careful with fakes here\n\n        except:\n            self.status = 'dis'\n            self.fake = True\n            self.device = 0\n            print('cant connect to lock-in. Using fake device.')\n\n    def set_voltage(self, voltage_in_volts: float):\n        '''sets amplitude in V for sin out'''\n#        amplitudeForLockin = voltage_in_volts * 1000  # volts to millivolts conversion\n        self.write('SLVL ' + str(voltage_in_volts) + 'V')\n\n    def getR(self):\n        # OUTP? i Query the value of X (1), Y (2), R (3) or θ (4). Returns ASCII floating point value.\n        self.write('OUTP? 3')  # request for R channel\n        voltage = float(self.read())  # read the lockin response in volts\n        return voltage\n\n    def getX(self):\n        # OUTP? i Query the value of X (1), Y (2), R (3) or θ (4). Returns ASCII floating point value.\n        self.write('OUTP? 1')  # request for R channel\n        voltage = float(self.read())  # read the lockin response in volts\n        return voltage\n\n    def getY(self):\n        # self.lockin.write('GAUT DAT3')  # autoscale the R channel\n        self.write('OUTP? 2')  # request for R channel\n        voltage = float(self.read())  # read the lockin response in volts\n        return voltage\n\n\n\n    def get_voltage(self, channel: str):\n        '''get voltage in channel channel'''\n        parameter = 2  # default request is R channel data\n\n        if channel == 'r':\n            parameter = 2  # request for R channel\n        if channel == 'x':\n            parameter = 0  # request for X channel\n        if channel == 'y':\n            parameter = 1  # request for Y channel\n        if channel == 't':\n            parameter = 3  # request for THETA channel\n\n        self.write('OUTP? %d' % parameter)  # request for data at #parameter channel\n        voltage = float(self.read())  # read the lockin response in amps\n        return voltage\n\n    def set_frequency(self, frequency_in_hz: float):\n        '''set the internal oscillator frequency in Hz'''\n        self.write('FREQ %f' % frequency_in_hz)  # set frequency\n\n    def set_phase(self, phase: float):\n        '''careful with commas in the float type. You might want to use int instead.'''\n        self.write('PHAS %d DEG' % phase)\n\n    def get_phase(self):\n        '''get phase of detection in deg'''\n        self.write('PHAS?')\n        return float(self.read())\n\n    def get_time_constant(self, getnext):\n        '''get time constant of the lock-in amplifier as a code. Decode to seconds.'''\n        self.write('OFLT?');  # what is your time constant in codes?\n        tc = int(self.read())  # read the response\n\n        # decode tc from code to seconds\n        def times(tm):\n            return {\n                0: 0.000001,  # 1 us\n                1: 0.000003,\n                2: 0.00001,\n                3: 0.00003,\n                4: 0.0001,\n                5: 0.0003,\n                6: 0.001,\n                7: 0.003,\n                8: 0.01,\n                9: 0.03,\n                10: 0.1,\n                11: 0.3,\n                12: 1,\n                13: 3,\n                14: 10,\n                15: 30,\n                16: 100,  # 100 s\n            }.get(tm, -1)  # default value to return is -1 that means smth went wrong and threw an error\n\n        if getnext:  # if next TC is required.\n            return times(\n                tc + 1)  # returns TC+1 in seconds, i.e. next largest time constant. Note the actual TC is not changed here\n        else:\n            return times(tc)  # by default return current TC\n\n    def set_time_constant(self, code:int):\n        self.write('OFLT %d' % code);  # set time constant with code CODE\n\n    def set_sensitivity(self, code: int):\n        '''I could have done it human-friendly, but sensitivity setting is not often in use. Plus not all values are alowed'''\n        self.write('SENS %d' % code) # sens, not scal!\n\n    def autophase(self):  # set autophase, wait 3TC until the signal is relaxed.\n        '''set autophase, wait 3TC until signal is relaxed'''\n        self.write('APHS');  # first set autophase\n        tc = self.get_time_constant(getnext=True)  # then get the time constant which is approx 3 times larger\n        from time import sleep\n        sleep(tc) # wait for that time\n        print('Phase corrected, waited 3TC = %d s to stabilize' % tc)\n\n    def checkLocked(self):  # useless junk but commands here are useful\n\n        self.write('FREQINT?')\n        status_string = 'INT: %.3f Hz' % float(self.read())\n        self.write('FREQEXT?')\n        status_string += '\\nEXT: %.3f Hz' % float(self.read())\n        self.write('FREQDET?')\n        status_string += '\\nDET: %.3f Hz' % float(self.read())\n        return status_string\n\n    def get_freqdet(self):  # gives the detection frequency\n        self.write('FREQDET?')\n        return float(self.read())\n\n    def print(self,s:str):\n        print('- LIA >> : %s'%s)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lock_in.py b/lock_in.py
--- a/lock_in.py	(revision 296ed967c938606051c88196226f4c1da5367d78)
+++ b/lock_in.py	(date 1661986236645)
@@ -175,5 +175,16 @@
         self.write('FREQDET?')
         return float(self.read())
 
+# this converts modulation amplitude in gauusses to modulation voltage in volts.
+    def convert_gauss2voltage(self, modulation, frequency):  # written by Emre Coltu
+        if frequency == 10000 and modulation < 0.315:
+            modulation_voltage = (30492 * pow(modulation, 4) - 18815 * pow(modulation, 3) + 3516.9 * pow(modulation, 2) + 20.45 * pow(modulation, 1) - 11.665 * pow(modulation, 0)) * 0.001
+        elif frequency == 10000 and modulation >= 0.315:
+            modulation_voltage = (141.54 * modulation + 11.45) * 0.001
+        elif frequency == 100000:
+            modulation_voltage = 0.27539 * modulation + 0.015642
+        return modulation_voltage
+
+
     def print(self,s:str):
         print('- LIA >> : %s'%s)
\ No newline at end of file
Index: workflow.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>cw plotter for lyra:\n1. delete second tree view\n2. press plot and plot the selected spectrum from the tree view\n\tadd new axes to plot\n\t\tadd dax variable to Plotter class for datasets\n3. instead of plot lets make 2 buttons: X and Y channels.\n(for now keep both)\n\n19/10/20\nmake three processes:\none runs gui.\nthe other runs communication to the spectrometer\nthird runs plotting\n\ndone!\n\nmake window for setting parameters: inspire yourself by xEpr.\nload from file button - load parameters from a given spectrum: load_btn\nset up all parameters in fields:\n\tB_start_etry\n\tB_stop_etry\n\tB_step_etry\n\t..\n\t...\n\t....\nsetup scan window is created. when all scan parameters are set, click set scan button\n..\n...\n....\nhow to implement electrochemistry here?\nscan is set. \nNow lets set electrochemistry\n0 mV - scan\n100 mV - scan\n...\n...\n...800 mV - scan\nwhat so we do here?\n\nwe go to 100 mV, do 10 scans, go back to 0mV and rest there, do another 10 scans.\n\nok hold on.\nwe made the set scan scan window.\nnow lets implement it as a seperate python module.\nLets call it setup_scan.py and let us import it in the GUI later. (make a button for that too)\n\n\n02/11/20\nreal testing.\nFake devices dont work now. Make sure they dont work accidently.\nconnect to lia and fc and run scan. No bridge, no resonator.\n\nwrite lines to devices was a bad idea\nimplementing nruns.\nnruns cycle implemented.\nImplementing averaging feature:\n\teach scan gives bvals[] and signal[]\n\tafter B0 cycle calculate list signal_averaged[] by averaging all scans that we had before. \n\tDont just add them up, weight! \n\tsignal_averaged = (signal_averaged + signal)/scans_that_have_been_done.\n\nadd live axes to the plotter. Plot live data in these axes. \nself.liveaxis = self.subplot.twinx()\n\nplot live data on live axes.\ngoing over averaged signal and how to assign its elements dynamically.\n1st run append,\nfrom second run average each point (last point each time)\n\n\nwrote save function for spectra in cw_spectrum class.\nmaking cw spectrum populating as the scan progresses\n\n03/11/20\nsaving file\npopulate nruns ok\nwtf is with the li_level why is that not saving? ok\nmodamp add dimension v\nlets populate npoints v\n\nultimate goal:\n\tdo electrochemical scan\nnext step:\n\twrite def echem_scan and mostly copy it from cw_scan\n\t\n04/11/20\nechem scan. сделаем затычку сначала done\nnow when press run button you run echem experiment instead of simple cw.\n\nI collect data.\nIt does not matter how I plot it,\nmain idea is to collect data.\n\nthe echem_scan method works with text.\nwrite cw scan method.\nWhat should it do?\nIt should give a scan back.\nnew_cw_scan = cw_scan(scan_setting,- b0 и так далее)\ncw_scan it is an object.\nit is created in its constructor.\nyou need to pass it parameters \nand you need to pass it a device communicator.\nThere we go.\n\ncw_scan gives a scan that is bvalues[] and signal[]\nlet us call it single_cw_scan()\n\ndef single_cw_scan(parameters: scan_setting, communicator: communicator)\n\tbvalues = []\n\tsignal = []\n\t\n\tbvalues_to_feed = scan_setting.b0s\n\t\n\tdef __init__(self):\n\t\tfor Bvalue_to_feed in bvalues_to_feed:\n\t\t\tcommunicator.set_magnetic_field(Bvalue_to_feed)\n\t\t\tmagnetic_field_value = communicator.get_magnetic_field()\n\t\t\tsignal_value = communicator.get_signal()\n\t\t\t\n\t\t\tbvalues.append(magnetic_field_value)\n\t\t\tsignal.append(signal_value)\n\t\t\tsleep if you need to. You probably need to!\n\t\t\t\n\t\t# at the end of this for, you populate bvalues and signal\n\t\t\t\n\t\t\t\nwritten set_field method in the bh-15 file. Dont confuse it with set_center_field\n\nnow we need to wait after setting the magnetic field.\nlets make it a field in the setup_scan.\ndelay = time constant of lia * (conv_time + 1) - addigned in setup_scan.set_scan()\n \nlets take delay from the setup_scan object and wait for this exact time\n\t\t\t\nok.\nnow lets record data from the lock-in amplifier.\n\nfor time being append B0s to signal\n\t\t\nplaying with plotting, it should not be so hard\ni can plot points in the plot, ok\nbut there are too many points\neach line should be a line instead.\n\nmaybe wiser would be to add elements to lines in the plots...\nit plots weongly\n\nwhats wrong\n\nit does not delete scan after it has been plotted...\n\nnow it can.\nit plots right.\nit does electrochemical scan and plots the line right.\n\nnow we want to accumulate each scan somewhere\nlets make a list of scans.\n\nlets add potential as a field to single_cw_scan\n\n\nplotting averaged. continue at line 590 in main gui\n\n\n09/11/2020 \nI am damn sure I have modified this file after 4th of November. \nNow we can talk to the potentiostat.\nIt can set voltage and hopefully beep.\nLets test it.\n\nIn the main_gui class lets go to the echem_scan\nand each time we set the new potential we would beep.\nechem_scan() is the guy we need.\nit beeps :3333333333333333333333333333333333333333333333333333\nI play wierd tunes on it\nOk it seems to work.\n\nNow save the spectra in the appropriate formats.\n\n10/11/2020\nI am on lyra.\nI am starting the code.\nI want to run it for two potentials.\n0 and 1000 mV\n\nI can talk to pot.\nformatted output does not work for python 3.5\nnado na morde pokazat u potentiostata eto. pust tok merajet hule emu budet\n\npochemuto lockin ne stavit sensitivity.\nstavit, suka, 100 uV, i vsio tut!\ngde bug?\n\nbug v kode.\n\nwhat controls that?\nscan setting.\nsetup scan tochnee\nhUi tam, netu tam. prichem suka otpravliaiet CODE=17, govorit po krainei mere. STOPE-\non pishet SCAL 17\nchto znachit scal 17\neto ne SCAL a SENS lool\nchtio takoe scal interesno#\nscal bylo na novom SRS 860, u kotorogo display is fancy.\npohui. ubirai nahui!\n\nsnimaem spektry\nn@c60 lezhit mezhdu 3365 i 3390\n\nlets display current field and the current potential\n\ndone\n\nplotting averaged data now.\nwe have a list of scans.\nWe want to plot the averaged value for them.\n\nLets take one scan.\nTake its bvalues and first plot the first scan only.\n\nI need a class.\ncw_spectrum fits for this!\n\nkoro4e\ncw spectrum bolshe ne klass.\neto budet method.\nkotory budet sozdavat class cw_spectrum()! okak\n\ncw_spectrum has a 'potential' field now.\n\nok now it is a spectrum that is returned by the method.\nnow echem_scan() operates with cw_spectra\nplot_averaged_data now.\nit takes a list[] of cw_spectra. [a b c d e f g ...]\nplot (a.bvalues, a.signal)\n\n\nit plots something but idk if that is averaging or not\n\nsaving in cw_spectrum sucks. it doesnt save the actual data!\n\nsignal is way too weak!\nnc60 should be higher at 22 db. Why. Am I wrong. How to check. FscII.\nEnough for today.\n\n------- next steps -------\n    in potentiostat, :SENSe:CURRent:RSENse ON fpr 4 wire measurements.\n    check with fscII that you have the right signal.\n    save individual scans.\n    save averaged scans.\n    in lockin, do both channels, not only R.\n\n11/11/2020\n\nso, we start with the potentiostat. we want it to be in 4 wire mode.\nfscII give a different spectrum!\nrecord X and Y, dont record R.\n\n    lets go to lock-in.py and create two methods. getX and getY.\n    there was a mistake. I was reading the Y channel ALL THE TIME!\n    done getX and getY.\n\n    in main_gui get the x and y, not r\n\n    what is wrong with the magnetic field?\n\n    do scaling of the plot\n\n    too many print operations. bh15 speaks too much.\n    disabeled visa log to screen\n\n    the scan is happening too slow\n\n    that seems to work but very slow. Will it make it overnight?\n    Idk. We should try.\n    How about saving files?\n\n    lets save averaged spectra at each high potential and also averaged spectra at 0 potential.\n\n    def make_spectrum_from_scans(high_scans: [cw_spectrum]): in cw_spectrum.py.\n    make a spectrum with averaged scans. then save it.\n\n    parameters are not saved in file. data is saved\n    parameters save from scan setting.\n\n    get mw frequency.\n    measurement delay for each point?\n    i fucked up the mod amp!\n    whyyyy but WHYYY!!!!\n\n    hmm. now when it is in volts, not in millivolts, all seem good. wtf\n\n    plotting is shit. saving is shit!\n    save in %.8e otherwise data is SHIT!\n\n    def set_limits_of_x_averaged_axis(self, low,high): a method in Plotter.\n    Used for scaling the axes so that you can see all that you plotted in this scan.\n\n    in main_gui.py, scale the axes and keep that scale.\n    when you plot the averaged data, just keep the scale the same.\n    I also added offsets for x and y channels ibo hule net. ne vidno je nihrena!\n\n    saving is ok.\n    modamp is ok.\n\n    mw freq needs to be recorded.\n    written agilent_53181a.py.\n    lets get frequency.\n\n    added freq counter to communication.\n    mw frequency is saved in files.\n\n    13/11/2020\n    we are ready to run the experiment\n    lets take a cw spectrum of a tube.\n    wowowowo lets first make a print of how much is left\n\n\n\n\n    damn pstat sets wrong voltage.\n    it is just a 4 wire measurement of current.\n    lets do it. properly.\n\n    potentiostat shit\n    it doesnt let me do electrochemistry#\n    i want 4 wire measurement of current, thats it.\n\nCURR:NPLC 0.5 ??? time for meas current??\n\n    pot works.\n    wtf is wrong with the mpl, why is that SO slow?!\n    plotting everything in one axis now\n\n\n\n16/11/2020\nechem scan going upwards and downwards.\n\n\n\n23/11/2020\nrecording currents at each potential point.\nCharging currents.\nWe may use them for making a kind of transient CV curve.\n\n\nlets create a file with charging curves and save the data in it.\n\n% structure of file %\ndate_time\npotential current time\n1          1e-2    0\n1          2e-2    1\n...\n...\n...\n\n\n\n24/11/20\n    something is wrong with the potentiostat reading. it triggers too often and too much.\n\n30/11/20\n    whats wrong with the time trigger?\n\n08/12/20\n    recording current transients at each potential. .chg file.\n    potentiostat does not like to trigger...\n\n\n11/12/20\n    parameter import errors. .2f potential added to comment.\n\n\n28/01/21\n    plotter.plot_averaged_data adds a negative shift to y every time :/\n    fix?\n\n03/02/21\n    added NRUN:int to echem_scan in main_gui.py\n    to run multiple scans\n\n    removed setting the limits in the plotter.plot_averaged_data\n\n\n    plotting: add https://pypi.org/project/mpldatacursor/\n    datacursor\n\n02/03/22\n    we go for scripts/\n    we want to use python scripts to run experiments.\n    for example, an experiment can be a class.\n    it has to be a class.\n    But one has to be able to change this class.\n    It is going to be \"unstable\"\n    but who ever cared about it?\n\n    what do we do:\n\n    it is magnettech. MS5000. It has ESRStudio.\n    it has to be controlled.\n    some things have to be set up by a human.\n    There can be an API. Fuck that. For now.\n\n    right_hand can be the module that presses certain buttons.\n    Again, autohotkey is doing the job for now so its okay.\n\n    what would exp look like:\n\n    импортировать спектрометр?\n\n    ок эмре сидит за компьютером и нажимает на кномки.\n    a file for experiment would be like this:\n\n    import emres_right_hand # the thing that clicks buttons\n    class my_experiment:\n    def __init__()\n        # scan an epr scan\n        potentiostat.set_potential()\n        emres_right_hand.cooldown()\n        emres_right_hand.scan_epr()\n\n\n\n\n    class experiment()\n        communicator: communicator\n\n09/03/22\n    so be it.\n    we have pyqt5 ui.\n    it is /gui/main/EMRE_MS5000.ui\n    lets import it instead of the header in the main file.\n    import EMRE_MS5000.ui with PyQt5 and run it.\n\n09/06/22\nhttps://stackoverflow.com/questions/48099359/embedding-matplotlib-figure-in-qtdesigner-gui\n- how to insert a matplotlib into a qtdesigner\nhttps://nitratine.net/blog/post/how-to-import-a-pyqt5-ui-file-in-a-python-gui/\n- how to import the ui file\n\n- how to import a python module dynamically\nx = reload(__import__(mod))eters\n    except ImportError:\n        print \"bargh! import error!\"\n        continue\n    try:\n        cls = getattr(x,'qux')\n    except AttributeError:\n        continue\n\na = cls()\nprint a.__class__.__name__\n\n31/08/22\nusb subuser has to be installed if you want to speak to usb devices on linux.\npython3-usb package for your linux has to be installed for pyvisa to see the USB devices.\n\ndoing device management in a device manageer window.\ntesting CV module with real pstat.
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/workflow.txt b/workflow.txt
--- a/workflow.txt	(revision 296ed967c938606051c88196226f4c1da5367d78)
+++ b/workflow.txt	(date 1661986236637)
@@ -421,12 +421,24 @@
         emres_right_hand.cooldown()
         emres_right_hand.scan_epr()
 
-
-
-
     class experiment()
         communicator: communicator
+27/04/2022
+        you speak to it.
+        what toys do we have:
+            emres_hand
+            potentiostat - implement the potentiometric mode at a given current
+            plotter
+            files
 
+        todo:
+            1. make a window with startups
+                Г--------------------------------х
+                |   connect to stmr              \
+                |   load script                  \
+                |   parameters to hardware       \
+                /   run                          \
+                ----------------------------------
 09/03/22
     so be it.
     we have pyqt5 ui.
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.9 (electron-magnetic-resonance-environment)\" project-jdk-type=\"Python SDK\" />\n  <component name=\"PyCharmProfessionalAdvertiser\">\n    <option name=\"shown\" value=\"true\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision 296ed967c938606051c88196226f4c1da5367d78)
+++ b/.idea/misc.xml	(date 1661986236658)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9 (electron-magnetic-resonance-environment)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.8" project-jdk-type="Python SDK" />
   <component name="PyCharmProfessionalAdvertiser">
     <option name="shown" value="true" />
   </component>
Index: main_pyqt.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main_pyqt.py b/main_pyqt.py
new file mode 100644
--- /dev/null	(date 1661986236655)
+++ b/main_pyqt.py	(date 1661986236655)
@@ -0,0 +1,63 @@
+# run the pyqt generated gui here (g.ui)
+
+from PyQt6 import uic
+from PyQt6.QtWidgets import QApplication
+from communication import new_communicator
+import Plotter # to plot electrochemistry at MS5000 and ESR on Lyra
+
+
+class EMRE:
+    form = 0   # here buttons live
+    app = 0    # idk why but oyqt creates this object too
+    window = 0 # same again, it is created as it has to be created
+    #cvPlotter = Plotter.CvPlotter # matplotlib plotter to plot the electrochemical data
+    communicator = 0 # communicator is the pyvisa-based interactive module that speaks to devices
+
+
+    def __init__(self):
+        Form, Window = uic.loadUiType("gui/pyqt/G-easy.ui")
+        self.app = QApplication([])
+        self.window = Window() #Qmainwindow
+        self.form = Form()
+        self.form.setupUi(self.window)
+
+        # now lets connect buttons from this form to actions
+        self.form.connect_btn.clicked.connect(self.connect_to_spectrometer)
+        self.form.load_script_btn.clicked.connect(self.load_script)
+        self.form.par_to_hw_btn.clicked.connect(self.par_to_hw)
+        self.form.run_btn.clicked.connect(self.run)
+
+
+        # inserting the plotter to the plotter frame:
+        #self.cvPlotter = Plotter.CvPlotter(self.window)
+
+        # finally, start the gui
+        self.app.exec()
+        self.window.show()
+
+
+    def connect_to_spectrometer(self):
+        print("connecting to spectrometer...")
+        print("initializing the communicator...")
+        self.communicator = new_communicator(backend = '',cvPlotter=self.cvPlotter)
+
+        #TODO: copy it from the main_gui_potential-sweep_sequence_adkustm.py
+
+
+    def load_script(self):
+        print("opening a file dialog...")
+        #TODO: file dialog open and choose the script from there
+        self.form.par_to_hw_btn.setEnabled(True)
+
+
+    def par_to_hw(self):
+        print("loading parameters to hardware...")
+        #TODO: can be connected to the loaded script
+        self.form.run_btn.setEnabled(True)
+
+    def run(self):
+        print('experiment running!')
+
+# main loop
+if __name__ == "__main__":
+    EMRE()
Index: .idea/plot_lyra_python.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<module type=\"PYTHON_MODULE\" version=\"4\">\n  <component name=\"NewModuleRootManager\">\n    <content url=\"file://$MODULE_DIR$\">\n      <sourceFolder url=\"file://$MODULE_DIR$\" isTestSource=\"false\" />\n      <excludeFolder url=\"file://$MODULE_DIR$/venv\" />\n    </content>\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.9 (electron-magnetic-resonance-environment)\" jdkType=\"Python SDK\" />\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n  </component>\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/plot_lyra_python.iml b/.idea/plot_lyra_python.iml
--- a/.idea/plot_lyra_python.iml	(revision 296ed967c938606051c88196226f4c1da5367d78)
+++ b/.idea/plot_lyra_python.iml	(date 1661986236660)
@@ -5,7 +5,7 @@
       <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
       <excludeFolder url="file://$MODULE_DIR$/venv" />
     </content>
-    <orderEntry type="jdk" jdkName="Python 3.9 (electron-magnetic-resonance-environment)" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.8" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
